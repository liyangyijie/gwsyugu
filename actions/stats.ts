'use server'
import prisma from '@/lib/prisma'

export async function getDashboardStats() {
    try {
        // 1. Aggregations (DB Side)
        // Total Balance: Sum of accounts with NO parent (independent/parent accounts)
        const totalBalanceResult = await prisma.unit.aggregate({
            _sum: {
                accountBalance: true
            },
            where: {
                parentUnitId: null
            }
        });

        // Arrears Amount: Sum of negative balances (independent/parent accounts only)
        // Note: Prisma aggregate doesn't support complex conditional sum directly in SQLite easily without raw query
        // But we can filter by accountBalance < 0
        const arrearsAmountResult = await prisma.unit.aggregate({
            _sum: {
                accountBalance: true
            },
            where: {
                parentUnitId: null,
                accountBalance: { lt: 0 }
            }
        });

        // Total Unit Count
        const unitCount = await prisma.unit.count();

        // 2. Arrears Count (Complex due to Parent/Child)
        // Logic:
        // - Count Independent/Parent units where balance < 0
        // - Count Child units where Parent's balance < 0
        //
        // This is hard to do in one standard Prisma query.
        // We can do it in two queries or one Raw Query.
        // Let's stick to Prisma for safety and simplicity if possible.
        // Or fetch just the necessary IDs/Balances to map in memory (much smaller than full fetch).

        // Actually, fetching "Units with parent" and "Units without parent" status is efficient enough
        // if we only fetch IDs and Balances.

        // But we want to avoid fetching 1000s of rows if possible.
        // Let's use two counts.
        // Count A: Independent Units in Arrears
        const countA = await prisma.unit.count({
            where: {
                parentUnitId: null,
                accountBalance: { lt: 0 }
            }
        });

        // Count B: Child Units in Arrears (depending on Parent)
        // We need to find children whose parent has balance < 0.
        const countB = await prisma.unit.count({
            where: {
                parentUnit: {
                    accountBalance: { lt: 0 }
                }
            }
        });

        const arrearsCount = countA + countB;
        const totalBalance = Number(totalBalanceResult._sum.accountBalance || 0);
        const arrearsAmount = Math.abs(Number(arrearsAmountResult._sum.accountBalance || 0));


        // 3. Warning Units (Prediction < 30 days)
        // We need to query the JSON field. SQLite JSON support in Prisma is experimental/limited for filtering.
        // However, we can fetch `UnitPrediction` table directly, which is smaller than Unit + Relation.
        // Or optimized: Fetch only predictions where the JSON string *might* contain low days? No, unreliable string match.
        //
        // Better approach:
        // Fetch all UnitPredictions (id, data).
        // It's effectively fetching the cache table.
        // If we have 1000 units, we fetch 1000 small JSONs. This is unavoidable without a dedicated 'days' column.
        // But we can select ONLY the necessary fields.

        const predictions = await prisma.unitPrediction.findMany({
            select: {
                unitId: true,
                data: true,
                unit: {
                    select: {
                        id: true,
                        name: true,
                        parentUnitId: true,
                        parentUnit: {
                            select: { id: true, name: true } // Need parent name? Maybe not for warning list itself, but for logic.
                        }
                    }
                }
            }
        });

        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const warningUnits: any[] = [];
        const processedUnits = new Set<number>();

        for (const pred of predictions) {
            try {
                // If this unit is a Child, its prediction data (if correctly generated by prediction.ts)
                // already contains the "Shared" result (isChild: true).
                // So we can trust the 'data' column if our prediction logic is robust.
                //
                // Prediction Logic (prediction.ts) says:
                // "Cache the Shared Result for the Child" -> Yes.

                const data = JSON.parse(pred.data);
                if (data.remainingDays < 30) {
                     warningUnits.push({
                        id: pred.unit.id,
                        name: pred.unit.name,
                        remainingDays: data.remainingDays,
                        estimatedDate: data.estimatedDate
                    });
                }
            } catch {
                // ignore
            }
        }

        // Sort
        warningUnits.sort((a, b) => a.remainingDays - b.remainingDays);

        return {
            success: true,
            data: {
                totalBalance,
                arrearsCount,
                arrearsAmount,
                unitCount,
                warningUnits
            }
        }
    } catch {
        return { success: false, error: 'Failed' }
    }
}
